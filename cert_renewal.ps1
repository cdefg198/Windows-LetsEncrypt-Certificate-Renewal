#Get certificates that are expiring in 4 days and store them in an array
$expiring = get-childitem -path Cert:\LocalMachine\My -Recurse -ExpiringInDays 4 
#I use the below line to filter out certificates issued by my internal CA or autogenerated by ADFS
#| where {$_.Issuer -notlike "*internalca*" -or -$_.Issuer -notlike "*adfs*"}

#check if the array has any expiring certificates and if it doesn't stop the script
if ($expiring -eq $null) {
    Write-Output "No Certificates are expiring"
    return
    }

#Import the AcmeSharp module and set a path for the storage of the PFX files used later
Import-Module acmesharp
$certpath = "c:\certs"

#I use Azure DNS so below I configure the connection parameters for connecting to Azure DNS
$azurepassword = cat "<hashed password file>" | ConvertTo-SecureString -Key (<hash key>) # take my hashed password from file and convert it into a readable password for PowerShell
$azureuser = "<azure username>"
$azurecreds = New-Object -TypeName System.Management.Automation.PSCredential -argumentlist $azureuser, $azurepassword

try {Add-AzureRMAccount -TenantId "<azure tenant ID>" -Credential $azurecreds -ErrorAction Stop}
catch {
        Write-Output "Azure failed to connect"
       return
       }

#process through the certificates in the $expiring array
foreach ($cert in $expiring) {
    $hostname = $cert.GetNameInfo( 'SimpleName', $false ) # This is the IssuedTo field on the certificate. 
    $WebAppName = $hostname.Split(".")[0] # Get just the subdomain
    $day = get-date -Format "ddMMyyhhmmss"
    $name = $hostname.Split(".")[0]+$day # identifying name to be used later for the LetsEncrypt request, dated so it is unique
    Send-MailMessage -To "<my email>" -From "<from address>" -SmtpServer "<smtp server>" -Subject "$hostname cert is being renewed" # I like to know the script is doing something

    New-ACMEIdentifier -Dns $hostname -Alias $name # Create a new LetsEncrypt cert request
    Complete-ACMEChallenge $name -ChallengeType dns-01 -Handler manual # Create a DNS challenge

    $challenge = ((Get-ACMEIdentifier $name).Challenges | Where-Object { $_.Type -eq 'dns-01' })[0].Challenge # find the request challenge and store it
    $recordname = ($challenge.RecordName).split(".")[0]+"."+($challenge.RecordName).split(".")[1] # get the LetsEncrypt record name that it wants for the DNS validation
    $domain=($challenge.recordname).Split([string[]]"$recordname.", [StringSplitOptions]"None")[1] #set the domain name using the LetsEncrypt request
    $rs = New-AzureRmDnsRecordSet -Name $RecordName -RecordType TXT -Ttl 60 -ZoneName $domain -ResourceGroupName Main  # create the Azure DNS record set
    Add-AzureRmDnsRecordConfig -RecordSet $rs -Value $challenge.RecordValue # # add the value for the record for LetsEncrypt DNS validation
    Set-AzureRmDnsRecordSet -RecordSet $rs # set the Azure DNS record
    Submit-ACMEChallenge $name -ChallengeType dns-01 # tell LetsEncrypt to check the DNS entry for validation of the domain
    #start a pause loop that waits for the challenge to validate
    do { Start-Sleep -Seconds 10 }
    while (((Update-ACMEIdentifier $name -ChallengeType dns-01).Challenges | Where-Object {$_.Type -eq "dns-01"}).status -ne "valid")
    write-output "challenge valid"

    New-ACMECertificate $name -Generate -Alias $name # create a LetsEncrypt certificate request
    Submit-ACMECertificate $name # submit the request to LetsEncrypt
    #Start a pause loop until the certificate is issued from LetsEncrypt
    do { Start-Sleep -Seconds 10 }
    while ((Update-ACMEcertificate $name).serialnumber -eq $null)
    write-output "certificate issued"
    Get-ACMECertificate $name -ExportPkcs12 "$certpath\$name.pfx" -CertificatePassword "<exported password>" # export the certificate to a PFX

    Import-PfxCertificate -FilePath "$certpath\$name.pfx" cert:\localMachine\my -Password (ConvertTo-SecureString -String "<exported password>" -Force –AsPlainText) # Import the certificate into the machines certificate store

    $Thumbprint = (Update-ACMEcertificate $name).Thumbprint # store the thumbprint of the issued LetsEncrypt certificate 
    $appID = (Get-WebApplicationProxyApplication -Name $WebAppName).id # get the App ID from the Web Application Proxy for the domain this certificate is for.  Assumes you've named the application in WAP the same as the subdomain of the domain you're getting a cert for
    Set-WebApplicationProxyApplication -ID $appID -ExternalCertificateThumbprint $Thumbprint # set the certificate in WAP for the App to the newly issued certificate 
    # get the certificate thumbprint of the app in WAP and then check it against the thumbprint of the cert issued by LetsEncrypt to make sure that it's assigned it correctly.  If it hasn't, send an email and continue to the next certificate needing renewal
    $appCertThumb = (Get-WebApplicationProxyApplication -ID $appID).ExternalCertificateThumbprint
    if ($appCertThumb -ne $Thumbprint) {
        Send-MailMessage -SmtpServer "<smtp server>" -Subject "$hostname cert failed to update" -To "<my email>" -From "<from address>"
        continue
        }
    #clean up the stored PFX file, remove the expired certificate and remove the DNS validation from Azure DNS if the above condition passes
    set-location cert:
    $oldThumbprint = $cert.Thumbprint
    Remove-Item -path Cert:\LocalMachine\My\$oldThumbprint -deletekey
    remove-item "$certpath\$name.pfx"

    Get-AzureRmDnsRecordSet -Name $recordname -RecordType TXT -ZoneName $domain -ResourceGroupName main | Remove-AzureRmDnsRecordSet
}
